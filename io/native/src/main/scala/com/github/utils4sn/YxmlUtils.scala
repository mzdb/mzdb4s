package com.github.utils4sn

import scala.collection.Seq
import scala.scalanative.unsafe._
import scala.scalanative.unsigned._

import com.github.mzdb4s.Logging
import com.github.sqlite4s.c.util._

import bindings._

object YxmlUtils extends Logging {

  private val YXML_BUFF_SIZE = 4096.toULong

  import YxmlLib._
  import enum_yxml_ret_t._

  def runSimpleTest()(implicit zone: Zone): Unit = {
    // encoding
    val xmlStr = """<scanList count="1">
 <cvParam cvRef="MS" accession="MS:1000795" name="no combination" value=""/>
 <scan>
   <cvParam cvRef="MS" accession="MS:1000016" name="scan start time" value="0.003213333333" unitCvRef="UO" unitAccession="UO:0000031" unitName="minute"/>
   <cvParam cvRef="MS" accession="MS:1000512" name="filter string" value="FTMS + p NSI Full ms [400.00-1200.00]"/>
   <cvParam cvRef="MS" accession="MS:1000616" name="preset scan configuration" value="1"/>
   <cvParam cvRef="MS" accession="MS:1000927" name="ion injection time" value="35.282913208008" unitCvRef="UO" unitAccession="UO:0000028" unitName="millisecond"/>
   <scanWindowList count="1">
     <scanWindow>
       <cvParam cvRef="MS" accession="MS:1000501" name="scan window lower limit" value="400.0" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
       <cvParam cvRef="MS" accession="MS:1000500" name="scan window upper limit" value="1200.0" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
     </scanWindow>
   </scanWindowList>
  <binaryDataArrayList count="2">
     <binaryDataArray encodedLength="148492">
       <cvParam cvRef="MS" accession="MS:1000523" name="64-bit float" value=""/>
       <cvParam cvRef="MS" accession="MS:1000576" name="no compression" value=""/>
       <cvParam cvRef="MS" accession="MS:1000514" name="m/z array" value="" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
       <binary>kis</binary>
     </binaryDataArray>
   </binaryDataArrayList>
 </scan>
</scanList>"""

    val callbackByTagName = Map(
      "binary" -> { xmlNode: XmlNode =>
        println("Got value: " + xmlNode.content )
        true
      }
    )

    println( callbackByTagName.contains("binary") )

    parseXmlChunk(CUtils.toCString(xmlStr), callbackByTagName)
    //parseXmlChunk(toCString(xmlStr))
  }

  def runSpectrumTest()(implicit zone: Zone): Unit = {

    // encoding
    val xmlStr = """<spectrum index="0" id="controllerType=0 controllerNumber=1 scan=1" defaultArrayLength="13921">
<cvParam cvRef="MS" accession="MS:1000579" name="MS1 spectrum" value=""/>
<cvParam cvRef="MS" accession="MS:1000511" name="ms level" value="1"/>
<cvParam cvRef="MS" accession="MS:1000130" name="positive scan" value=""/>
<cvParam cvRef="MS" accession="MS:1000128" name="profile spectrum" value=""/>
<cvParam cvRef="MS" accession="MS:1000504" name="base peak m/z" value="445.120056152344" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
<cvParam cvRef="MS" accession="MS:1000505" name="base peak intensity" value="3.108478125e05" unitCvRef="MS" unitAccession="MS:1000131" unitName="number of detector counts"/>
<cvParam cvRef="MS" accession="MS:1000285" name="total ion current" value="3.0275545e06"/>
<cvParam cvRef="MS" accession="MS:1000528" name="lowest observed m/z" value="400.000187125691" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
<cvParam cvRef="MS" accession="MS:1000527" name="highest observed m/z" value="1207.886649627127" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
<scanList count="1">
  <cvParam cvRef="MS" accession="MS:1000795" name="no combination" value=""/>
  <scan>
    <cvParam cvRef="MS" accession="MS:1000016" name="scan start time" value="0.003213333333" unitCvRef="UO" unitAccession="UO:0000031" unitName="minute"/>
    <cvParam cvRef="MS" accession="MS:1000512" name="filter string" value="FTMS + p NSI Full ms [400.00-1200.00]"/>
    <cvParam cvRef="MS" accession="MS:1000616" name="preset scan configuration" value="1"/>
    <cvParam cvRef="MS" accession="MS:1000927" name="ion injection time" value="35.282913208008" unitCvRef="UO" unitAccession="UO:0000028" unitName="millisecond"/>
    <scanWindowList count="1">
      <scanWindow>
        <cvParam cvRef="MS" accession="MS:1000501" name="scan window lower limit" value="400.0" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
        <cvParam cvRef="MS" accession="MS:1000500" name="scan window upper limit" value="1200.0" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
      </scanWindow>
    </scanWindowList>
  </scan>
</scanList>
<binaryDataArrayList count="2">
  <binaryDataArray encodedLength="148492">
    <cvParam cvRef="MS" accession="MS:1000523" name="64-bit float" value=""/>
    <cvParam cvRef="MS" accession="MS:1000576" name="no compression" value=""/>
    <cvParam cvRef="MS" accession="MS:1000514" name="m/z array" value="" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
    <binary>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</binary>
  </binaryDataArray>
  <binaryDataArray encodedLength="74248">
    <cvParam cvRef="MS" accession="MS:1000521" name="32-bit float" value=""/>
    <cvParam cvRef="MS" accession="MS:1000576" name="no compression" value=""/>
    <cvParam cvRef="MS" accession="MS:1000515" name="intensity array" value="" unitCvRef="MS" unitAccession="MS:1000131" unitName="number of detector counts"/>
    <binary>UMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALKQAERyvC5EaupVRFjVWUROpTJEloYORAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAX4rBQ8LNKkSWtFREEFUrRGufiUMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM7TEkR8j4FEckmWRHQ+e0R4/yxEz0frQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARw27QyRYY0SHg7REWkXARAS/jUQEsRFEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMskLQz5AQ0R/m7xEG0ngRGuMsUSEJitEBPjhQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASmQLRCrOqUTHwA1FvYQfRf8e+kSSYYRErZmpQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAc8bsQyL3PURqwnpEyAaBRE6XeUTKtnpE6mhFRNnsyEMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOWQ50Oohl9EpvSJRJBejkSNoY1EpBBtRBInA0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtWpUOQ2l5EEmCsRF4gtEQYhIFEcW/hQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF1auQ3rcLEQcOlVE1Ps8RI1fz0MAAAAAAAAAAD7EE0T0MF9E6IVrRAAvNUQ5judDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvmJARGevp0TX4p9EvpswRLikakIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGzlRENCODlEVhqVREwwnkQQuWVE+dPIQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbmoVQw7laEQgSCdFEO6CRfi6jEXWH2NFtRMaRZRA1kSN1p1EpEsvRIDjGEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHPy2EMEkndEznqxRA7spUSCn0VEsTaQQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWtc5QzWKg0TU5ctEa3jFRJ/ShERmxAVEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYSgFEAJJfRPHUp0S+Vs1E9aPFRGGjiUQXR7tDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYmBFEggBnRKZ/UUR6AXdECnemRCUtkkQqexxEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxosMRLqqtUTLS/5Ew4TkRHAvbEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARgZ9DmOOCRLTbMkVAuIdFWpCLRdNWSEVzbshEjh9KRAonNkQccU5EI8WGRBDyo0Q8aZ9E/J9bRFUAu0MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChjF0TBrJtETkC5RB+Gn0TasXpEnDxrRCogT0TrtupDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADe7BJERps8REZZSUTEMDFEr1fnQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARSSMQybTLERft4BE4k2dRFJKpEQIlX1EA4/qQwAAAAAAAAAAAAAAAAAAAAAAAAAA6C8WRHaPUESSgk5EehMzRLyCG0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIK0FkS+qpVEGunFRJPs6kQW9iBFio1IRfi5NkVmddVEnVu4QwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJB0NQz5+UETMJ6tEkAKjRMqwO0SG/0NDAAAAAAAAAABPUclDytAtRKA0TEQwnERENK8gRAAAAAAAAAAAAAAAAAAAAAB4hwdE1H0sRI7RM0QwfixE0JQZRAAAAABr+qtD+2TWRE7eHEXbbf9ETncvRACE1kEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUO7UP473lENsycRFKOhEQgsR5EAAAAANS5ikLSompEZTDpRI89C0UrUPBEpj2oRAaRZ0Qk0DREYp4ERAAAAAAAAAAAeGMQRLG94UQWA5dFPgj/RTURFkbGgP1FGh+WRXVV6ESFNvBDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC135xDls0xRGBkiEQkf5FEth5dRMJ6BERdEtxDJDQyRFozhkSD645ERlZTREBdGkQAAAAAAAAAAAAAAAAAAAAAcmkfRLhnYUQ1z4tEW9S0RLFb/UQSRCJFqRohRcPu3URiOkZEpjcLRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkMMYRMBSRkSEk0xErq0vRPUe/EMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABohIESELDZE/CVIRO5HN0RhrvNDAAAAAAAAAACWSQxETCaHRHsrlURIBV5EINEDRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE83PQ+GptkSdvQ9F8x0XRc7p20S+QVBErrd/QwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkdXeQ3pnbkQTlJxEqkmURMi8X0SsNRREAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKWRZEum9ARORCXER83VJE7t40RLacKESqBDtEEH1PRPqyTUQOITVEGfToQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWgwhRLrfNESqJDBEmsg9RIqlSUQ+JjNE+u8DRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtGGKQoxzCkW7JQhGLreORrOGxkaUH8NGEyaHRqfx9UW7n+lE+HaqQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEoMNRMy1cESaf5hEiAtxRLH0k0MAAAAAAAAAAAAAAAAAAAAAvEwORJJxYUTCJV9ESNo8RJfkgER5+qFEotqDRBmwvkMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHCcyUGS6opEwcKnRbW7M0bOtXtGdr55Ri+WL0YBlqBFwtBnRD4MA0MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIHkhUNKzlNEFXCDRDJhiURfS5NEaZObRC8rkkQ8MmtEnHMsRMTtBUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHzIGUSswVdFaangRU1wF0YuxxBGtVTFRZqYNEW6ny5EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYEcMRPp1TUSiMo5EBmGmRIcSlkRS3kJELeKqQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJpkJRKJwr0RyeSpFSMlhRcjzU0WxxgxFYG5uREy9mEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIWd8UMwPjVEvlFvROiuf0TSrFtEUtEKRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADM8JRDK6RES4o19EpAAACjjVECpp7RFbBekTsb0dEynQYRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7WPeQ57LX0Qd5pBEmUWERCD1KEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOw4H0Q0iGxEQvqKRGr3U0TTvIVDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsVSdE8CpJRAKEbUQE+lpEJe76QwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuHoHRFACXETXVZNEahyfREGblURueH1ELOY8RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5pEVRGXEiURv9q5ECUutRKj+jkTKzFBEGjYPRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACSSOEQFWJ5Eej/QRBEDukTk7TtEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaoRhEFWCAROtlokTV4qRE1A6QRLwyfkQ6hHhEuBBoRI7wMEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0F8UPbSptE0JDHRBnqlkQd67ZDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEtClEznqgRIaStUSAtY1EjiUiRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEHorRC6kZUSqWG9ECGlURDwWKUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANZKI0Q4wWdEY4yWREcip0SahYpETPIcRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbBYqRAxTT0TwqItEr66rRHpHrURxQIhEmGM4RKhgIkRiWk5EumRuRNjgRkTRDNdDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAqQVERrduRFZ1ikRqD31EIPFbRFiIN0Q00whEHopMRJCupkQ6LaxECs5TRDTf40IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABL3G0TOclxEAnx/RBxTgUQJOIBEBdqARAC6bERyRjBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACGESZE+I9yRB4rh0R74ZBEI7SXRAr8cUR7srlDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIcDZE3GJlRAzTeERGzmREhM0URAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwiw+RBAHWUQ0rllEqidzRD/vhUQuCWJE0hNZRJCWoERAA7RE8lWHRP385UMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHggCETu0btES0cSRQkNJEWkzgtFyv2vRDSJD0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhUCER6hVREPVaqRBqnzUQlpuxEy58ZRWV1O0VaAS9FLcHgRGKJOUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOitGkQ+j21EP7qWRDSDj0Redj5EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsdAxEQHNoRHedhkS+fl5Ea9fxQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnrsgRHiKTkSew3FEerJSRMXi6EMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZ9ZkPePUhEQsKNRLnngETMxS5EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABWXSNE1AhvRBKKZkQ8plJEBvM1RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwqscRBAdf0SvcKNEmzWURGgiJUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABcp0UPAA0pEWh9kRDjPSkQKTStEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADq7hhE5EpSRDQaa0RmKlZEwtxBRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAd2+wQxTVbUSu15ZEZAh3RCVC9EMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGec0UMmYEpE1mhyRBihS0SqGAhEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB65x9EIg5pREbDeUQ0+oBEgsp0RGheS0Q49jZEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGihpEtCdvRDJhp0SzUqtE3qleRDjQNUMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPShJEQg9kxE1lNtRGwXdESEai9EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADNyZxDpm5dRKwul0Sv/KFEnFOdRORwgUQ+OBBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADUowxEduFpRDU3g0QA3V9EfDAvRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGY//Q3A4ZERiS5FEz0+RRL47dET2qU1EHMJORIh9QUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABD/GEQNdYZEdM+KRPStW0RXiIREzB2WRGIEP0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACaXZkO+MWhEaL6WROokakQlyfVDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyjD1DOjJTRIhpr0S3Ia9EjohKRFCk70EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH7yG0SkjHpEnFyRRFBvk0SmOa5E7MXDRJCeqER60VpE//i9QwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyNcqRPooW0QMrXdEfHBvRMSWOkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALJbKkT2m3dEUDN1RNCEc0RsTotEpluURBwNcETgzg1EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADdwupDhNRWRN6zgkT4zVlEyzroQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXBcERCV6l0SBi9hEVffvROfc0ETsxYZEVfDTQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlqQ0RDyAbUS87YpE8U6KRBalVkT9YtxDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIRwVEMWyCRNaGoERsv4xEtC41RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoB9BRK72lUSUjMlE9wL8RGzAEUXqFxdFfAcIRde9zERmZmZEDqUzQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiAE2RDKHc0Su+H1EJMhoRFLITkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+e4UOlBIVE7ljMRPGw9UTBa+FEZ1+IRBxtIkMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFzsIURRtJZE8FbXRNMtAUWB+/1EkWm8RG6lNkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFxLFUTFd5JEvJOuROAslEQI7C9EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABW0A1E6kBYRKO0j0THWYJEYMAlRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMMMqROqogkR/z5dEVcaJRFRdVkTG4BlEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwjhNE9lZURLaQeUQuAWZE/OEiRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIKg4RBpWhUSjXaBEAJOzRP3bxESTecBEBxqkRAa5fUS4BDFEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYkk5EW0uIRGc+s0RjBrpEH5yORFj/JUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIDGRkTf35ZE4Q+yRGOzu0ThcLFEx2WNRHhrNkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADi8IUQc5HJE4SSMRDwchkRKzGJE6B8eRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWjwiREoUdkTwArFExqXFRNc+mUQheP5DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUIlFEMKuARKDQjkSOm3hEdIM1RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyKElRCjTgUQKCYdEahVVRGhQCUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQGD0T4+F9EeOSBRAQcfkTkV2tEykBZRBKzQUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA30qkPS9lNEFfSbRErGpERU2mlErQOsQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/HgLRAqYaETimY5E3VeARI5RHEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAULUSgNWpE3PJ4RKwkfUSQ0YNEXtuGRF5+fEQU0zdEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK2XlDYDNZRK50hUTWNFVE4uMCRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUngjRHrdnERFgtpEdwL6RGcQ+ERLNudE8rfSRJW6rEQgVF5EScOsQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJDxGRLpahkRkjZ1EgBqcRE3uiURqdlxEC9z7QwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARrgoRL9ngkT9dKJE/tibRNzQV0QSaQ1EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD1AtdDKthiREghi0TckV5EB/juQwAAAAAAAAAAAAAAACCrD0SMcGtEJLN5RFZVdUSdAIJEAcSRRMhHmkT3FotEsvtARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKB1AROFSnUQVyLpEyKS5RGrMp0RHaYZESBktRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9ngjRJC9YkRWhIdEqi9mRNF060MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADKPUETmDJFEyguYRL83iETgcFpE3hVIRApecURs0YlEatJvRPSAAkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB7WD0SkyFxE1yiLRPFPmESQS31EvYz2QwAAAAAAAAAAbnhFRBlUhkTKYYVEblJgRH5TOEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKypJ0R3UoREcUilRKiMtERlsq1EpkiGRM5ECUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMZOPEQHUpBE/dqVRHR0eUTmnzNEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUHkxEK3uCRNY+gkRYd2dEGu44RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMsk8RP/NxETVHRNFk4kcRd2a60QsG2lE5HNZQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPW3eQwSTY0RFEYhE3EB8RKRJbEQM/WJEbvYwRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjej2Q3IddUS6sIdEnEpURMJ3GkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGTNAEQgsHpE+IyjRNFJn0TyBHdE2CkhRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWlsURJhkaEQi7n1E7B1eRPgGQ0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ70T0To54NE5x+GRDz5Y0TCTilEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADcPCJEEk9URPTQXkSK91REojYiRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AgHRISEcEQ284NETMxiRHDCRkTmi2dE0FuCRP4UXEQGVQtEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADJfvJDeFGZRIleu0QwjZVEztchRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALioORA55XkRFbIREvuyWROhwpUST1p5E3rh8RHxqJ0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB78IURyUlxEObGOROg9l0Qo4W5EtZTaQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhkI8RCIpgkTbvZVEhcCaRAzDj0SakmBESEsHRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArSGsQ9ZEW0RWMZZEIRWCRPY5EUQAAAAAAAAAAOYAOkTS+1tEiot3RJJfaUS+vg1EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABWdjFEo5iKRLh0sUS+27FEigSYRLuCiUSvlI5Es2+GRJgTNkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJDBSUTI2IpEksKWRDc9ikQQyWpEzohLRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAglUxRMmmkETvsZREZrZmRJBeGkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPJkF0RH96FEtLbURDrBzERBWplE1JOORAtm7UQwEC5FX05NRSQVT0UFFUBFMyYtRT67F0V+fwFFRfntRJsO+ERBhvxEYR7sRAcE7USvBhFF70M1RcJaTUVtalRF395ORfx5PkUEiCNFeZIFRRVo3URt3rVEjP6ARAj+B0QAAAAAAAAAAAAAAAAo20ZESKRbROCHWERA4YlEuGKaRFhzZUSLl6ZD+xXUQ1xAdESQOplEDrJvRDuRhUMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZtKUSIVV9EaFdyRB7FcERG/W9Eas9eRNY3FUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJXEkRnKJBEokfNRKJA20RgqqlEejAzRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMs0lRK7uYkRwy3tEaqhvRHi8PEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALjpFES8UHREM3yKRJDAekQARz5EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/Ss1D9G5VRK3qiEQCEHJEFNYORAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALlk0RMZucESgFYdECuVrRDw7HkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM23+ENmfXFEMPGPRMBHWUQBG6FDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6ziBEQhJ6RDFopkQn07FEDG6eRNSEnkRFq6ZEqx+QRMqTZER+iD5EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACdP/pD0iV2RH5Rn0Rwt59EtTSQRNLWbUQ+vCdEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEfDFEZjaBRG/plURq04BEXDAsRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATfnwQ+TgdUSOoJdELj6YRNKQkkRx0oZEogNPRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAakY1RKXQk0QzYbJEZiyuRLnKkUQcoEdEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABaQVNEBIiNRLS1oUSs35REYiNRRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADopPRJSelkRO859ExAOHRI4ROUQAAAAAAAAAAJVB1kNw2oFEWjarRCTNmUQmDklEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1z9xDMxW8RGvK/kTHCv9E11rVRAdWt0QdaLxE2pOjRBg7HkQAAAAAAAAAAAAAAAAAAAAAqGo8RGoYcURyW5JEKEiJRKwzTUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMZcFkSQNVZEUViBRICCWESFaN1DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEhgpENAJjRGbVj0TEGYVEaNMRRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPuw8RIgWXUSOZHtEVeKARDwMVkRjMP5DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAvBpEWDNqRKgxlkTWjZREMIpjRAQLGUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABpmS0QOMmJE/KyFROrDo0QriLlEJei1RDXtkkS6tTtEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq4ShE7HtwRFcDgURoiGBE0A9WRN4aSkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABqpEEQ8i3BEWtKERA72YkRWSzFEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4z0NECSmTRPLSq0QFlZlEjKVYRDZwFkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACYnKURGEnVERgOLRDboc0S6oENEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2QBtE5yqGRCOLk0SsdndE1iU1RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqP89RKpAf0Q6wYtEGDh0REhXM0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPgyM0TKI2dEaCZ6RPZtY0QeZWJEWMtTRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwrFCRI4weURqiopEHo1zRNxWM0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKZsC0SthIhELNagREuvrkSie69E7TOJRG6PGEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJKaIUQgs2lEzEyJRAW4ikTGT2lESqcQRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANANRRBbXZESsT3VEFiJyRJobOUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMTtTUScnYtE3rCeRLTkn0TbYppEHMmKRGpfTEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPYgFESyFIBE02ueRJJfj0SmFk1EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8PSlEVpxYROZ8YkQED1xEgkE+RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtrlWRCbQlEQBAppEfFN3REBHGEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPRBFESACF1EHDpwRMbKckQGu21EODlLRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAopQtRNIrf0SLQZVEVU+GRChVPkQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</binary>
  </binaryDataArray>
</binaryDataArrayList>
</spectrum>"""

    val callbackByTagName = Map(
      "binary" -> { xmlNode: XmlNode =>
        println("Got value: " + xmlNode.content )
        true
      }
    )

    println( callbackByTagName.contains("binary") )

    parseXmlChunk(CUtils.toCString(xmlStr), callbackByTagName)
    //parseXmlChunk(toCString(xmlStr))
  }

  def runSpectrumHeaderTest()(implicit zone: Zone): Unit = {

    // encoding
    val xmlStr = """<spectrum index="0" id="controllerType=0 controllerNumber=1 scan=1" defaultArrayLength="13921">
<cvParam cvRef="MS" accession="MS:1000579" name="MS1 spectrum" value=""/>
<cvParam cvRef="MS" accession="MS:1000511" name="ms level" value="1"/>
<cvParam cvRef="MS" accession="MS:1000130" name="positive scan" value=""/>
<cvParam cvRef="MS" accession="MS:1000128" name="profile spectrum" value=""/>
<cvParam cvRef="MS" accession="MS:1000504" name="base peak m/z" value="445.120056152344" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
<cvParam cvRef="MS" accession="MS:1000505" name="base peak intensity" value="3.108478125e05" unitCvRef="MS" unitAccession="MS:1000131" unitName="number of detector counts"/>
<cvParam cvRef="MS" accession="MS:1000285" name="total ion current" value="3.0275545e06"/>
<cvParam cvRef="MS" accession="MS:1000528" name="lowest observed m/z" value="400.000187125691" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
<cvParam cvRef="MS" accession="MS:1000527" name="highest observed m/z" value="1207.886649627127" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
<scanList count="1">
  <cvParam cvRef="MS" accession="MS:1000795" name="no combination" value=""/>
  <scan>
    <cvParam cvRef="MS" accession="MS:1000016" name="scan start time" value="0.003213333333" unitCvRef="UO" unitAccession="UO:0000031" unitName="minute"/>
    <cvParam cvRef="MS" accession="MS:1000512" name="filter string" value="FTMS + p NSI Full ms [400.00-1200.00]"/>
    <cvParam cvRef="MS" accession="MS:1000616" name="preset scan configuration" value="1"/>
    <cvParam cvRef="MS" accession="MS:1000927" name="ion injection time" value="35.282913208008" unitCvRef="UO" unitAccession="UO:0000028" unitName="millisecond"/>
    <scanWindowList count="1">
      <scanWindow>
        <cvParam cvRef="MS" accession="MS:1000501" name="scan window lower limit" value="400.0" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
        <cvParam cvRef="MS" accession="MS:1000500" name="scan window upper limit" value="1200.0" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/>
      </scanWindow>
    </scanWindowList>
  </scan>
</scanList>
</spectrum>"""

    val callbackByTagName = Map(
      "cvParam" -> { xmlNode: XmlNode =>
        println(xmlNode.attributes.toMap)
        //println("Found node: " + xmlNode.tagName )
        true
      }
    )

    parseXmlChunk(CUtils.toCString(xmlStr), callbackByTagName)
    //parseXmlChunk(toCString(xmlStr))
  }

  def parseXmlChunk(xmlStr: CString, callbackByTagName: Map[String, XmlNode => Boolean])(implicit zone: Zone): yxml_ret_t = {

    val yxmlBuf = alloc[Byte](YXML_BUFF_SIZE)

    val yxmlPtr: Ptr[yxml_t] = stackalloc[yxml_t] // no need to free because we are on the stack :)
    yxml_init(yxmlPtr, yxmlBuf, YXML_BUFF_SIZE)

    // Implicit conversion of struct
    val yxml = new implicits.struct_yxml_t_ops(yxmlPtr)

    var attr_name: CString = null // = (char*) malloc(128);
    //var attr_value_ptr: Ptr[CChar] = null
    //var attr_value_ptr_max: CInt = -1
    //var attr_value_buf: Ptr[CChar] = stackalloc[CChar](128) // read byte (tmp in YXML doc)

    /*char *attr_value_ptr = NULL, *attr_value_buf = NULL;
    int attr_value_ptr_max = -1;*/

    val nodeContentCStrBuilder = CStringBuilder.create()
    val nodeContentAsStrWrapper = new CStringWrapper(c"", 0.toULong)

    val nodeAttrs = new collection.mutable.ArrayBuffer[(String,String)]()
    val attrValueCStrBuilder = CStringBuilder.create()

    var xmlTagName: String = null
    val xmlNode: XmlNode = new XmlNode(tagName = "", content = nodeContentAsStrWrapper, attributes = nodeAttrs)

    var elemCbOpt = Option.empty[XmlNode => Boolean]
    var isCbDefined = false
    var continueParsing = true

    var doc: Ptr[CChar] = xmlStr
    while (doc.unary_! != 0 && continueParsing) {  // for each char of the XML chunk

      val yxml_rc: yxml_ret_t = yxml_parse(yxmlPtr, !doc)

      if (yxml_rc < 0) {
        return yxml_rc
      } else if (yxml_rc == YXML_OK) {
        // parsing ok, but no particular event
      } else if (yxml_rc == YXML_ELEMSTART || yxml_rc == YXML_ELEMEND) {

        // If end of current node or if we start a new node and that a callback is currentl defined
        if (isCbDefined){
          //println("YXML_ELEMEND")

          // Create XML node
          nodeContentCStrBuilder.addChar(CUtils.NULL_CHAR)
          nodeContentAsStrWrapper.c_str = nodeContentCStrBuilder.underlyingString()
          nodeContentAsStrWrapper.length = nodeContentCStrBuilder.length()

          // Execute callback
          continueParsing = elemCbOpt.get.apply(xmlNode)

          // Reset some vars
          elemCbOpt = None
          isCbDefined = false
        }

        if (yxml_rc == YXML_ELEMSTART && continueParsing) {
          //println("YXML_ELEMSTART")
          //println("elemstart " + fromCString(yxml.elem))

          // Retrieve corresponding callback if any
          xmlTagName = fromCString(yxml.elem)
          elemCbOpt = callbackByTagName.get(xmlTagName)
          isCbDefined = elemCbOpt.isDefined

          // If callback is defined clear XML node content
          if (isCbDefined) {
            //println("a callback is defined for this elem")
            xmlNode.tagName = xmlTagName
            xmlNode.offset = yxml.total.toLong

            nodeContentCStrBuilder.clear()
            nodeAttrs.clear()
          }
        }

      // Parse current node only if we have a defined callback
      } else if (isCbDefined) {

        if (yxml_rc == YXML_ATTRSTART) {
          attr_name = yxml.attr
          //println(fromCString(attr_name))
          attrValueCStrBuilder.clear()
        } else if (yxml_rc == YXML_ATTRVAL) {
          //val data = !yxml.data
          //val first_byte = (!yxml.data)._1
          val first_byte = !(yxml.data).at(0)
          //println( "got char: " + first_byte )

          attrValueCStrBuilder.addChar(first_byte)

          // Note: old way of dealing with attrs
          /*while (!attr_value_buf != null && attr_value_ptr < attr_value_ptr_max)
            *(attr_value_ptr++) = *(attr_value_buf++);

          if (*attr_value_buf) { // this means that attr_value_ptr >= attr_value+sizeof(attr_value)
            return YXML_ESTACK;
          }*/

        } else if (yxml_rc == YXML_ATTREND) {
          if (attr_name != null) {
            attrValueCStrBuilder.addChar(CUtils.NULL_CHAR)
            //println(fromCString(attr_name))
            // Add parsed attribute to the ArrayBuffer
            nodeAttrs += (fromCString(attr_name) -> fromCString(attrValueCStrBuilder.underlyingString()))
          }
          // Note: old way of dealing with attrs
          /*if (attr_value_ptr != null) {
            attr_value_ptr = null
            attr_value_ptr_max = -1
          }*/
        } else if (yxml_rc == YXML_CONTENT) {
          //println("YXML_CONTENT")
          //println("YXML_CONTENT "+ fromCString(yxml.elem))

          // FIXME: get other bytes (multiple bytes are returned in the several cases, see 'yxml.h' comments)
          //val first_byte = (!yxml.data)._1
          val first_byte = !(yxml.data).at(0)
          nodeContentCStrBuilder.addChar(first_byte)

          //println("got byte: " + first_byte.toInt)
          //println("got char: " + new String(Array(first_byte), Charset.defaultCharset()))
        }
      }

      // got to next char of the XML document
      doc = doc + 1
    }

    // We have to destroy the CStrBuilders
    nodeContentCStrBuilder.destroy()
    attrValueCStrBuilder.destroy()

    val eof_rc = yxml_eof(yxmlPtr)
    val yxml_rc = if (eof_rc < 0)
      eof_rc /* Invalid EOF */
    else
      enum_yxml_ret_t.YXML_OK; // NO ERROR*/

    yxml_rc
  }
}

class XmlNode(
 var tagName: String,
 var content: CStringWrapper,
 var attributes: Seq[(String,String)],
 var offset: Long = 0L
)